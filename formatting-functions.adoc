= Formatting Functions - draft
:imagesdir: /images
:toc:
:numbered:

////
https://powerman.name/doc/asciidoc
_**XXX is far from being implemented, mention it here?**_
////

== Introduction

The purpose of this document is to: 

* Provide an overview of goals, design ideas, and considerations
* Show examples of function use, dialects, and output
* Raise questions about what features to support


== Overview

While chatting with Nenad about a formatting system, the basic goals he
outlined were:

	printf() from C + format$() from VB, on steroids for Red 
	(working on as many datatypes as possible).
	
	We also want possible column-oriented formatting, to make 
	it easy to ouput tabular data. So a pad or align command 
	would be required. Could this be done with a second dialect
	that takes a list of column specs and generates format
	strings?

I have an old R2 `format` function that was inspired by VB's `format$`
function patterns, which grew out of BASIC's `print using`, and is also
used in many spreadsheets for cell formatting. I first thought I would
just port that code to Red, but it had a lot of assumptions built in,
had no concept of international formatting, and was designed for my 
needs, not those of a wider community.

Printf support, as a goal, also seemed easy enough. I wrote a basic
`printf` parser and let that sit. Once I got more work done on mask-
based formatting, and stepped back to look at things from the top,
it became clear that supporting traditional `printf` syntax wasn't a
good fit. For example, conversion specifiers are not needed, because
we have a rich type system to drive that, which also makes the hash(#)
flag obsolete. The `%` sigil also doesn't work well, because Red uses
that for `file!` values. A similar problem faces the standard `$` 
sigil used for string interpolation in other languages. Red will use
that for `money!` values.

The design process is both top down and bottom up. Start with ideas
and examples from a user's perspective, then build a bit to support
one aspect. Find issues you didn't consider from the outside, move
back up and revisit assumptions, build another piece. See how those
two pieces fit together in a larger picture, and where your blue
sky design falls apart. Only by building things will you start to 
really feel what works, what doesn't, and where the most devilish
details start to pop up.

== Use Cases

- Format single values
- Format a block of values
- Support formats suited to each datatype
- Interpolate formatted values into a block
- Interpolate values in a string
- Create a formatted row
- Create a formatted column
- Create a table
- Generate values in report templates (build-markup)
- Format cells in spreadsheets
- Format given a mask
- Format given a width
- Format a number given whole and fraction/decimal widths?
- Format a number given total and fraction/decimal widths
- Allow fill string and alignment overrides
- Support international formatting
- Support named formats

== Goals and Design Decisions

I looked at a lot of formatting systems over time, and they all
boil down to a few main paradigms, each just adding their own
flavor and features. VB and COBOL use mask-based formatting
(called a PICture clause in COBOL). C, Common Lisp, and...everything
that followed suit, uses a very terse command string to define the
total width of a field, number of decimal places, and a few other
rudimentary options (e.g., sign and fill char). The third paradigm
is parameterized masks or forms. .NET and Wolfram both use this 
approach. Add localization and exact/inexact number support, and
you have a wide range of combinations.

One goal, then, is to make the options managable and usable. Another
is to make them flexible. A third is to keep things simple. Pick any
two.

The draft submission for a `format` design won't be exhaustive. There
are a lot of details yet to be covered. What I hope to do is lay the
foundation for a design that allows new features to be added as needs
are discovered.

Another important element is taste. You may not like mine. In some
ways I want to push the boundaries forward, in others I want to limit
them. For example, Red is a data language, and highly symbolic. We
don't often exercise that, but it's there. Because of that, I think
Wolfram is an important system to learn from. On the other hand, C
(and `printf`) herald from a system level view, which I think holds 
less value in Red. For example, `printf` has no concept of group
separators in numbers. Those are helpful, even for programmers. Why
would you *not* include them?

There is the issue of internationalization. We can format the data
for ourselves, but someone else may be looking at it in another part
of the world, and ambiguity can be a terrible thing. Leaving out
group separators doesn't solve the problem, because the decimal 
point may still be a dot/full-stop or a comma. What we need, then,
is a universal numeric format that is unambiguous. We can also call
this a "round-trip" form and is, coincidentally, natively supported
by Red.

We can't force people to do the right thing. All we can do is make
the right thing really easy to do, and discourage bad behavior.
As you read the notes here, or evaluate the draft code, keep that
in mind. The goal is not to be all things to all people, or to 
support existing formats because blub programmers will be happy to
see it and may adopt Red (they won't). 

=== General dialect thoughts.

- Sigils should be chosen for use in a Red context, not simply
taken from other languages. This is important. We can't judge
things too quickly, because they're unfamiliar, but still have to 
acknowledge when certain characters make things look like noise.

- A lot of history exists for formatting layouts and patterns.
That should not be ignored. The primary driver here, for me, is
spreadsheets. And while we're thinking at the code level, there
will almost certainly come a time when an format editor tool 
will be built.

- We aren't designing for a single target audience or use case.
As programmers, we may think that something like `printf` is
enough, and everything beyond that is just bloat and wasted code.
If you've ever had to write formatted output for business use,
you know this is not the case, and a *huge* amount of effort goes
into the tiny details. To this end, we won't have a single dialect
that covers all our needs, even if there ends up being a single
`format` function that is an entry point.

== Values

We should leverage types for all they're worth. While it will be nice of
us to support formatting float! as percent!, or as money! (AHHH!), we
really need to tell people to use appropriate datatypes.

Being able to access values, when formatting more than a single value at
at time, including structured values, is convenient. The ability to do
this has to be balanced against complexity and risk (security).

== Interpolation

In addition to interpolating values in strings, as other languages do,
we should be able to interpolate formatted values into blocks. 

== Masks versus specifications

Formatting via masks has a rich history. "#,##0.00" tells you what it's
going to look like, at least roughly. It's a WYSIWYG model. You can tell
it will have 2 decimal places, at least one leading zero, and use the 
comma as a group separator. There are subtleties of course. ".00" may 
mean "at least", "at most", or "exactly" 2 digits. If you figure out that
"#" means an optional digit, you can guess ".00" doesn't mean "at most".
It still doesn't tell you which of the other two it is. 

Specifications, as used in `printf`, give you 2 widths. e.g., %5.2f. You
might think that's clearer, but it's not. Is 5 the total width, or the
number of whole digits? The min/max/exact question is the same.

To know the behavior, you need to read the docs. Even then, formatting
behavior isn't always clear. Once you take into account sign options,
alignment, group separators, and alternate fill characters.


== Format Styles (Named formats)

Long format masks don't work well in interpolated strings, and are a pain
to type repeatedly. Terse, short-format specs aren't always immediately
clear in what their output looks like. The strengths of one are the 
weaknesses of the other. The solution I'm moving toward is "named styles".
It's not a new concept, but the approach I've taken is more like using
style sheets than trying to build in every style and locale combination.
The library of them will naturally grow over time, and may become standard,
especially in larger internationalized systems. The standard system should
cover basic needs, and allow users to easily extend it.


== Short Formats (ala `printf`)

Short-formats are like `printf`, but not exactly the same. Don't compare
the output to `printf` as a point of reference.

NOTE: The exact behavior isn't nailed down on this yet. The current implementation
      allows the deci point to float, based on value, precision, and alignment.
      That's how printf seems to do it, at least some of them. It feels like
      spec'ing a precision should make that part fixed.

- Flags are "<>_+0Zz$¤º"
  [left-align right-align space-for-+  +-for-+  zero-fill(0Zz) money($¤) ordinal]
  0 is a bit confusing in some cases, because it could be the last flag char, but
  then you may have leading 0s in the width, that follows. Have to decide if
  it's worth keeping. `¤` is not a well-known character but is a universal currency
  symbol, but `$` is most universal. If we want to use something that is replaceable,
  for localization, and clearly not USD, `¤` makes sense. Otherwise `$` seems best.
  `£` and `€` are the next most common characters to consider, but suffer the same
  specificity problem as `$`. Rebol supports 3-letter ISO4217 codes on money! vals.
  See: https://en.wikipedia.org/wiki/Currency_sign_(typography)

- Width+precision are [m][.n] 

The sigil is the hardest thing to choose. `%` is for files in Red. I like `:`,
since it is like `get-word!` syntax, implying that we're getting a value to
interpolate into a string. If we also end the format with it, it's a get-set op,
implying getting a value and applying the format to it. The other big question
is whether short-format strings need to be structured. e.g. :[...]: or :(...):.
I think those apply to string interpolation, not single value short format
applications.

The biggest downside to `:` as a sigil is time values.

Alt sigil ideas: _=&@! But I don't really care for any of them.

I don't like ~ or ` as sigil options either.

Escaping the sigil with the standard escape character isn't beautiful either
(`^^:`), but I don't want to double characters as an escape mechanism when
we already have a known escape pattern.


== Contexts and Functions

_**There are some long and some terrible names in place. Known and sometimes intentional.**_

Naming is important, and more thought will go into things. As I
work through examples, I sometimes need to give things names that
are very clear, breaking pieces down by named functionality. But
I can't pick the best names, because the structure isn't nailed
down yet. This also affects dependencies. As code is merged, 
more common bits can be shared.

There are likely to be multiple contexts under the formatting
banner, but the current code structure isn't intended to be the
final design.

There are functions for internal use, functions intended as the
public API, and functions that may be useful and so are exported
from the contexts. We'll label these Private, Major, and Minor,
respectively.

=== List of current funcs

....
    Name                     Type   Purpose

    Composite                Major  Replace :( ... ): sections with their evaluated results.
    ordinal-suffix           Minor  Return the ordinal suffix for a number (th, st, nd, rd, etc.)
    as-ordinal               Minor  Return the ordinal string for a number (1st, 2nd, 3rd, etc.)
    format-bytes             Major  Return a string containing the size and units, auto-scaled by default
    format-logic             Major  Format a logic value as a string, custom or named format
    form-num-with-group-seps Minor  Insert group separators into a numeric string
    format-by-width          Minor  Formats a number given a total length and a maximum number of decimal digits. No separators added.
    format-number-with-mask  Minor  Return a formatted number, using a mask as a template
    format-number-via-masks  Minor  Format, selecting the mask based on the number's value
    format-number-with-style Minor  Return a formatted number, by named style
    short-form               Major  Format and substitute values into a template string
    block-form               Major  Format and substitute values into a template block
    format                   Major  General formatting entry point (TBD)
....

Other helper funcs will also be added. `Format` will be the main entry point,
and will dispatch to sub-funcs like `format-number`, `format-date-time`, etc.,
based on datatype. It may also dispatch based on style. e.g., if the style name
given is `bytes`, it will dispatch to `format-bytes`. Row, column, and table
formatting may be addded as well. I have an old string formatter, including
capitalization and case control. Those aren't currently included.



=== Composite

> "Replace :( ... ): sections with their evaluated results."

The name of the function (`composite`) is tricky. Rebol calls this
`build-markup`, which isn't bad, but defines a more limited view of its 
use, as well as implying that you are building the markup itself, when
the markup is really the template you're filling in. 

We want a word that says it operates on a single argument, so things like
`intersperse`, `substitute`, and `interject` don't read as well to me. It sounds
like they take something(s) to insert. `Inset` is too close to `insert`. Another
option is a neologism, like `interform`, which implies both putting a thing in a
place, and `form`ing it. `Composite` is generally used as a term related to
image processing, which is a possible point of confusion. It is also both a noun
and a verb, which works well in this case.

There isn't much to this function in the way of design, with only a couple
major decisions to be made:

1. What are the start/end markers for substitution expressions.
2. What do we do in the case of mismatched markers.

The `:( ... ):` markers already have meaning in Red. Colons are used to
get and set values, and parens indicate evaluation.

Putting the colons on the outside gives you a clean paren expression on the
inside. Rebol used `<% ... %>` as its markers, inspired by PHP I think, and
comfortable for tag-people I suppose. We shouldn't rule a tag-based syntax
out entirely.

One of the big questions is what to do if there are mismatched expr markers. We
can treat them as errors, or just pass through them, so they will be visible in
the output. We can support both behaviors with a refinement, and then just need
to choose the default.

Examples:

....
Composite
    ""                      == ""
    ":(1):"                 == "1"
    ":(pi):"                == "3.141592653589793"
    ":(rejoin ['a 'b]):"    == "ab"
    "a:('--):b"             == "a--b"
    "a:('--):"              == "a--"
    ":('--):b"              == "--b"
    "ax:(1 / 0):xb"         == "ax *** Error: zero-divide Where: 1 / 0 *** xb"
    ":("                    == ":("
    ":('end"                == ":('end"
    "):"                    == "):"
    ")::("                  == ")::("

	"alpha: :(rejoin ['a 'b]): answer: :(42 / 3):" == "alpha: ab answer: 14"

    ; No sample data to go with this in the doc
	{
		name: :(form-full-name cust):
		rank: :(as-ordinal index? find scores cust):
		ser#: :(cust/uuid):
	}

    ; With spaces around the expressions
	"a :('--): b"           == "a -- b"                                             
	"a :('--):"             == "a --"                                                 
	":('--): b"             == "-- b"                                                 
	"ax :(1 / 0): xb"       == "ax  *** Error: zero-divide Where: 1 / 0 ***  xb"

Composite/err-val input "#ERR"

    "ax:(1 / 0):xb"         == "ax#ERRxb"
    "ax :(1 / 0): xb"       == "ax #ERR xb"
....

=== ordinal-suffix

> Return the ordinal suffix for a number (th, st, nd, rd, etc.)

Examples:
....
....

=== as-ordinal

> Return the ordinal string for a number (1st, 2nd, 3rd, etc.)

Examples:
....
....

=== format-bytes

> Return a string containing the size and units, auto-scaled by default

Examples:
....
....

=== format-logic

> Format a logic value as a string, custom or named format

Examples:
....
....

=== form-num-with-group-seps

> Insert group separators into a numeric string

Examples:
....
....

=== format-by-width

> Formats a number given a total length and a maximum number of decimal digits. No separators added.

Examples:
....
....

=== format-number-with-mask

> Return a formatted number, using a mask as a template

Examples:
....
....

=== format-number-via-masks

> Format, selecting the mask based on the number's value

Examples:
....
....

=== format-number-with-style

> Return a formatted number, by named style

Examples:
....
....

=== short-form

> Format and substitute values into a template string

Examples:
....
....

=== block-form

> Format and substitute values into a template block

=== format

> General formatting entry point (TBD)

Examples:
....
....




